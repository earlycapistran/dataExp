#' Residual analysis for GLS models
#'
#' This function evaluates residuals from 'gls' model objects. 
#' It returns #' a normality plot, residuals vs. fitted values, 
#' and a lag plot with a trend line
#' (residuals vs. lagged residuals) to evaluate autocorrelation. It also
#' provides a Shapiro-Wilk normality test, Levene's test for 
#' homogeneity of variance, the Durbin-Watson test 
#' for autocorrelation, and a t-test for zero mean.
#'
#' @param gls_object A 'gls' model object generated by the 'nlme' 
#' package.
#'
#' @importFrom car leveneTest
#' @importFrom stats shapiro.test
#' @importFrom stats residuals
#' @importFrom stats fitted
#' @importFrom stats sd
#' @importFrom stats qqnorm
#' @importFrom graphics plot
#' @importFrom graphics par
#' @importFrom graphics abline
#' @importFrom stats dt
#'
#' @export
#'
#' @examples
#' # Load required libraries
#' library("car")
#' library("nlme")
#' 
#' # Fit a GLS model
#' data(Orthodont)
#' model <- gls(distance ~ age, data = Orthodont, correlation = corAR1(form = ~ 1 | Subject))
#'
#' # Analyze GLS residuals
#' analyse_gls_residuals(model)
#'

analyse_gls_residuals <- function(gls_object) {
  
  # Load required libraries
  library(nlme)
  library(ggplot2)
  
  # Load and prepare data -----------------------------------------------------
  resi <- resid(gls_object)
  resDf <- as.data.frame(resi)
  fit <- fitted(gls_object)
  
  # Subset residuals by sign
  resDf$sign <- as.factor(ifelse(resDf$resi < 0, "negative", "positive"))
  
  # Store lagged residuals
  resDf$resi_lag <- c(resDf$resi[-1], NA) 
  
  # Make plots ----------------------------------------------------------------
  par(mar = c(1, 1, 1, 1)) # Adjust margins
  
  # Normality
  graphics::par(mfrow = c(2, 2))
  stats::qqnorm(resDf$resi)
  stats::qqline(resDf$resi)
  
  # Residual vs. fitted values
  res.plot <- graphics::plot(x = fit, y = resi,
                             xlab = "Fitted values", 
                             ylab = "Residuals",
                             main = "Residuals versus fitted values")
  graphics::abline(h = 0)
  
  # Lag plot with trend line (residuals vs. lagged residuals)
  graphics::plot(resDf$resi, c(resDf$resi[-1], +  NA),
                 xlab = "Residuals", 
                 ylab = "Lagged residuals",
                 main = "Autocorrelation") 
  graphics::abline(lm(resDf$resi ~ resDf$resi_lag))
  graphics::par(mfrow = c(1, 1)) 
  
  # Run tests -----------------------------------------------------------------
  norm <- stats::shapiro.test(resDf$resi)
  levene <- car::leveneTest(resDf$resi ~ sign, data = resDf)
  
  # Calculate Durbin-Watson test manually
  n <- length(resi)
  dw <- sum(diff(resi)^2) / sum(resi^2)
  p.value <- 2 * (1 - pnorm(abs(dw), mean = 0, sd = 2))
  durbin <- list(statistic = dw, p.value = p.value, alternative = "two.sided")
  
  result <- list(normality = norm, levene = levene, durbin = durbin)
  names(result) <- c("Residual Normality Test", 
                     "Levene's Test", 
                     "Durbin-Watson Test")
  print(result)
  
  # Run t-test for mean = 0 ---------------------------------------------------
  stDev <- stats::sd(resDf$resi)
  mean <- mean(resDf$resi)
  degF <- length(resi) - length(gls_object$coefficients)
  t.value  <- abs(mean/stDev)
  p.value <- dt(t.value, df = degF)
  tResult <- cbind("Residual mean" = mean, "t-value" = t.value, "p-value" = p.value)
  rownames(tResult) <- c("")
  
  cat("$ `t-Test for residual mean zero`\n")
  print(tResult)
  cat("Alternative hypothesis: true mean is not equal to 0\n")
}
